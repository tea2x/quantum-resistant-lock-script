import { slh_dsa_sha2_128f, slh_dsa_shake_128f } from "@noble/post-quantum/slh-dsa";
import { promises as fs } from "fs";

/**
 * Reads a file and converts its hex content to a Uint8Array.
 * @param {string} path - Path to the hex file.
 * @returns {Promise<Uint8Array>} - Parsed byte array.
 */
async function readHexFileAsBytes(path) {
  try {
    const content = await fs.readFile(path, "utf-8");
    const hexString = content.trim().replace(/^0x/, ""); // Remove "0x" if present
    return new Uint8Array(
      hexString.match(/.{1,2}/g).map((byte) => parseInt(byte, 16))
    );
  } catch (error) {
    console.error("Error reading signature file:", error);
    throw error;
  }
}

/**
 * Reads and parses a JSON file containing public and private keys.
 * @param {string} filePath - Path to the JSON file.
 * @returns {Promise<{publicKey: Uint8Array, secretKey: Uint8Array}>} - Parsed keys.
 */
async function readKeysFromJson(filePath) {
  try {
    const data = await fs.readFile(filePath, "utf-8");
    const { pubkey, prikey } = JSON.parse(data);
    return {
      publicKey: new Uint8Array(pubkey),
      secretKey: new Uint8Array(prikey),
    };
  } catch (error) {
    console.error("Error reading keys from JSON:", error);
    throw error;
  }
}

/**
 * Extracts the signature and message from the imported signature file.
 * @param {Uint8Array} importedSignature - Raw imported signature bytes.
 * @returns {{ signature: Uint8Array, message: Uint8Array }} - Separated signature and message.
 */
function extractSignatureAndMessage(importedSignature) {
  const messageLength = 32;
  return {
    signature: importedSignature.slice(0, -messageLength),
    message: importedSignature.slice(-messageLength),
  };
}

/**
 * Writes a Uint8Array as a hex string to a file.
 * @param {Uint8Array} data - The data to write.
 * @param {string} filePath - The path to the file.
 * @returns {Promise<void>} - A promise that resolves when the file is written.
 */
async function writeHexToFile(data, filePath) {
  const hexString = Buffer.from(data).toString("hex");
  await fs.writeFile(filePath, hexString, "utf8");
}

async function testcase1() {
  console.log(">>> ___________________Noble verifying sphincs+C signature___________________");
  const keys = await readKeysFromJson("./key.json");
  console.log(">>> Keys generated by sphincs+ ref: ", keys);

  const importedSignature = await readHexFileAsBytes("./signature.txt");
  console.log(">>> Signature by sphincs+ ref: ", importedSignature);

  const { signature, message } = extractSignatureAndMessage(importedSignature);

  const originalMessage = await readHexFileAsBytes("./message.txt");
  console.log(">>> The message sphincs+ ref signed: ", originalMessage.toString());
  console.log(">>> Detached message (the last 32 bytes of the signature): ", message.toString());

  const isValid = slh_dsa_shake_128f.verify(keys.publicKey, message, signature);
  console.log(">>> Noble sphincs+ verifying the signature: ", isValid);
}

async function testcase2() {
  console.log(">>> ___________________Sphincs+C verifying noble signature___________________");
  const keys = await readKeysFromJson("./key.json");
  console.log(">>> Keys generated by sphincs+ ref: ", keys);

  const originalMessage = await readHexFileAsBytes("./message.txt");
  console.log(">>> The message sphincs+ ref signed: ", originalMessage.toString());

  const noblesignature = slh_dsa_shake_128f.sign(keys.secretKey, originalMessage);
  const combinedData = Buffer.concat([noblesignature, originalMessage]);
  await writeHexToFile(combinedData, "./noble_signature.txt")
  
  // now go to ckb tools to pick and verify it
}

async function main() {
  // await testcase1();
  await testcase2();
}

// Main execution
main();
